module increment (
//declare the clk and the rst signal before the always block
    input clk,  // input clock signal 
    input rst,  // input reset signal
    output out[16] // 16-bit ouput
  ) {
  
  // creat an 16-bit register is basically 16 copies of 1-bit dff
  dff register_1[16](#INIT(0), .clk(clk), .rst(rst));  // the INIT value is set to 0 and .clk(clk) to connect the clk signal of the dff with the clk signal of increment similarly for .rst(rst)
  
  // declare the adder
  adder increment1;
  
  // slow down the clk signal fed to increment by using this in-built component called counter
  // #SIZE(n) : defining how many bits is its output
  // #DIV(i) value: number of bits used as the divisor
  // clk signal that synchronizes this unit
  // rst signal
  counter slowClock(#SIZE(1), #DIV(26), .clk(clk), .rst(rst));
  	edge_detector slowClockEdge(#RISE(1), #FALL(0), .clk(clk));

  always {
  // two important terminals, .d for input and .q for output.
    slowClockEdge.in = slowClock.value;
    increment1.a = b00000001;
    increment1.b = register_1.q;
    increment1.alufn_signal = 4b0;
    
	 
    if (slowClockEdge.out == b1){ //only add when MSB of slowCLock == 1
     register_1.d = increment1.out;
    }
	  out = increment1.out;
  }
}
